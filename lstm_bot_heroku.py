# -*- coding: utf-8 -*-
"""LSTM-Bot-Heroku.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mWbEW0DFZOJiS6cHAyBalU8xFljfl0eg
"""

#!pip install python_binance 
import numpy as np
import random
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow
from tensorflow import keras
import binance
from tensorflow.keras.layers import LSTM,Dense
from tensorflow.keras.models import Sequential
from binance.client import Client
from binance.enums import *
import time as time
import datetime
import requests
import ta
import math
import smtplib

def formatPrice(n):
    return ("-$" if n < 0 else "$") + "{0:.2f}".format(abs(n))

def send(mess):
  # Configuration SMTP | Ici ajusté pour fonctionné avec Gmail
  host_smtp = "smtp.gmail.com"
  port_smtp = 587
  email_smtp = "amadofuentescarrillo2@gmail.com" # Mon email Gmail
  mdp_smtp = "vkqdzmoyjuspziww"  # Mon mot de passe

  # Configuration du mail
  email_destinataire = "yanisyanis545@gmail.com"
  mail_content = mess

  # Création de l'objet mail
  mail = smtplib.SMTP(host_smtp, port_smtp) # cette configuration fonctionne pour gmail
  mail.ehlo() # protocole pour SMTP étendu
  mail.starttls() # email crypté
  mail.login(email_smtp, mdp_smtp)
  mail.sendmail(email_smtp, email_destinataire, mail_content)
  mail.close()

send("coucou yanis")

#récuérer les poids du Denoiser et du LSTM grâce à GitHub
#!git clone https://github.com/yanis112/LSTM_weight.git
checkpoint_path1='denoiser_30_weight.hdf5'
checkpoint_path2='lstm_30_weight_volume.hdf5'

def destring(list):
    a=[]
    for k in list:
      a.append(float(k))
    return(a)

#fonctions de normalisation dénormalisation des prix
def normalize(list):   
  maxi=max(list)
  mini=min(list)
  a=[]
  for i in list:
    if (maxi-mini)==0:
      a.append(0.5)
    if (maxi-mini)!=0:
      a.append((i-mini)/(maxi-mini))
  return(a)




def init():
  model=Sequential()
  model.add(LSTM(64,return_sequences=True,input_shape=(30,2),dropout=0.3))  #64-256 selon clément
  model.add(LSTM(64,return_sequences=False,dropout=0.3))
  model.add(Dense(64,activation='gelu'))
  model.add(Dense(units=2,activation='softmax'))
  model.compile(optimizer='adam', loss='binary_crossentropy',metrics=['accuracy'])
  return(model)

model=init()
model.load_weights(checkpoint_path2)

def truncate(n, decimals=0):
    r = np.floor(float(n)*10**decimals)/10**decimals
    return str(r)

def merge(tab1,tab2):
  l=[]
  for k in range(len(tab1)):
    l.append([tab1[k],tab2[k]])

  return(np.array(l))

def get_BTC_balance():
  client = Client(api_key, api_secret)
  balance = client.get_asset_balance(asset='BTC')
  return(balance)

get_BTC_balance()

def get_USD_balance():                       
  client = Client(api_key, api_secret)
  balance = client.get_asset_balance(asset='USDT')

get_USD_balance()

def is_bought():
  client_ftx = ftx.FtxClient(api_key='SH6WTFG2zpVi3-1JTAMbaf7tlDO6Ng1LbQTcAhgg',api_secret='stiLn1NlokBaHlfZOLTSkYxGaNpPwJIHQPmYO4Ac')    
  fiat=get_USD_balance()
  cryp=get_BTC_balance()
  if fiat<0.01:
    return(True)
  else: 
    return(False)

is_bough()

#Lancement de la boucle infinie

while True:

  #Connexion à FTX
  pairSymbol =  'BTC/USD'         
  fiatSymbol = 'USD'                 
  cryptoSymbol = 'BTC'             
  myTruncate = 4                  
  client_ftx = ftx.FtxClient(api_key='SH6WTFG2zpVi3-1JTAMbaf7tlDO6Ng1LbQTcAhgg',api_secret='stiLn1NlokBaHlfZOLTSkYxGaNpPwJIHQPmYO4Ac')                 
    
  # Récupérer les montants
    
  fiatAmount=get_USD_balance()
  fiatAmount=1000
  cryptoAmount=get_BTC_balance()

  #Récupération des prix
  api_key='K2MmwHx4c4xKDP0LWSfuDCNMuFUOtU64U4OKuRYncY7ZPCPgJEUIW9xucrdrI5UV'
  api_secret='iLb0ZDB1bKMZ8o6mTXAW5xtmF4ULtwDigVuQLXCntUh0MUesjfA5jcndAJdAxrc4'
  client_binance=binance.client.Client(api_key,api_secret)
  client_binance.get_account()
  data2=pd.DataFrame(client_binance.get_historical_klines('BTCUSDT','1h','10000 m ago UTC'))  #'30 m ago UTC'
  prix=data2[1].tolist()
  volume=data2[5].tolist()
  prix1=destring(prix) 
  volume1=destring(volume) 

  state_pri = np.array(prix1[-51:-1])
  state_vol = np.array(volume1[-51:-1])

  #on détermine l'action
  action=model.predict(np.array([merge(state_pri,state_vol)]))[0]




  if action[0]>=action[1] and not is_bought() and it!=0:
      print("Buy: " + formatPrice(prix1[-1]))
      quantityBuy = truncate(float(fiatAmount)/prix1[-1], myTruncate)
      try:
        buyOrder=order = client.create_test_order(symbol='BTCUSD',side=SIDE_BUY,type=ORDER_TYPE_LIMIT,timeInForce=TIME_IN_FORCE_GTC,quantity=quantityBuy,price=prix[-1])
      except :
        send("buy failed")
      #print(buyOrder)
      coin=fiatAmount/prix1[-1]
      


  elif action[1]>action[0] and is_bought() and it!=0:
      is_bought=False
      try:
         buyOrder=order = client.create_test_order(symbol='BTCUSD',side=SIDE_SELL,type=ORDER_TYPE_LIMIT,timeInForce=TIME_IN_FORCE_GTC,quantity=quantityBuy,price=prix[-1])
      except:
        send("sell failed")
      print(buyOrder)   
    
      
      
  else :
      print("hold")
      send("holding")
  
  time.sleep(60*5)
